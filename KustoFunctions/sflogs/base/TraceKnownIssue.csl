.create-or-alter function with (docstring = "[T:string] where T=table name. function to search service fabric sflogs for known issues",folder = "sflogs/base") 
    TraceKnownIssue(T:string) {
        // search any column using string contains
        let AnyContains = (tableName:string, issue:string, query:string) {
            table(tableName) 
            | extend KnownIssue = iif((* contains query), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::any contains: ', query), "")
        };
        // search any column using regex sensitive match
        let AnyMatches = (tableName:string, issue:string, query:string) {
            table(tableName) 
            | extend KnownIssue = iif((* matches regex query), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::any matches: ', query), "")
        };
        // search any column using regex insensitive match
        let AnyIMatches = (tableName:string, issue:string, query:string) {
            let iQuery = strcat('(?i:',query,')'); // re2 case insensitive
            table(tableName) 
            | extend KnownIssue = iif((* matches regex iQuery), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::any imatches: ', iQuery), "")
        };
        // search Type And Text column using string contains
        let TypeAndTextContains = (tableName:string, issue:string, typeQuery:string, textQuery:string) {
            table(tableName) 
            | extend KnownIssue = iif((Type contains typeQuery and Text contains textQuery), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::type contains: ', typeQuery, ' ::text contains: ', textQuery ), "")
        };
        // search Type And Text column using regex sensitive match
        let TypeAndTextMatches = (tableName:string, issue:string, typeQuery:string, textQuery:string) {
            table(tableName) 
            | extend KnownIssue = iif((Type matches regex typeQuery and Text matches regex textQuery), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::type matches: ', typeQuery, ' ::text matches: ', textQuery ), "")
        };
        // search Type And Text column using regex insensitive match
        let TypeAndTextIMatches = (tableName:string, issue:string, typeQuery:string, textQuery:string) {
            let itypeQuery = strcat('(?i:',typeQuery,')'); // re2 case insensitive
            let itextQuery = strcat('(?i:',textQuery,')'); // re2 case insensitive
            table(tableName) 
            | extend KnownIssue = iif((Type matches regex itypeQuery and Text matches regex itextQuery), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::type matches: ', typeQuery, ' ::text matches: ', textQuery ), "")
        };
        // search Text column using string contains
        let TextContains = (tableName:string, issue:string, query:string) {
            table(tableName) 
            | extend KnownIssue = iif((Text contains query), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::text contains: ', query ), "")
        };
        // search Text column using regex sensitive match
        let TextMatches = (tableName:string, issue:string, query:string) {
            table(tableName) 
            | extend KnownIssue = iif((Text matches regex query), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::text matches: ', query), "")
        };
        // search Text column using regex insensitive match
        let TextIMatches = (tableName:string, issue:string, query:string) {
            let iQuery = strcat('(?i:',query,')'); // re2 case insensitive
            table(tableName) 
            | extend KnownIssue = iif((Text matches regex iQuery), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::text imatches: ', iQuery), "")
        };
        // search Type column using string contains
        let TypeContains = (tableName:string, issue:string, query:string) {
            table(tableName) 
            | extend KnownIssue = iif((Type contains query), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::type contains: ', query), "")
        };
        // search Type column using regex sensitive match
        let TypeMatches = (tableName:string, issue:string, query:string) {
            table(tableName) 
            | extend KnownIssue = iif((Type matches regex query), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::type matches: ', query), "")
        };
        // search Type column using regex insensitive match
        let TypeIMatches = (tableName:string, issue:string, query:string) {
            let iQuery = strcat('(?i:',query,')'); // re2 case insensitive
            table(tableName) 
            | extend KnownIssue = iif((Type matches regex iQuery), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::type imatches: ', iQuery), "")
        };
        // search Type or Text columns using string contains
        let TypeOrTextContains = (tableName:string, issue:string, query:string) {
            table(tableName) 
            | extend KnownIssue = iif((Type contains query or Text contains query), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::type or text contains: ', query ), "")
        };
        // search Type or Text columns using regex sensitive match
        let TypeOrTextMatches = (tableName:string, issue:string, query:string) {
            table(tableName) 
            | extend KnownIssue = iif((Type matches regex query or Text matches regex query), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::type or text matches: ', query ), "")
        };
        // search Type or Text columns using regex insensitive match
        let TypeOrTextIMatches = (tableName:string, issue:string, query:string) {
            let iQuery = strcat('(?i:',query,')'); // re2 case insensitive
            table(tableName) 
            | extend KnownIssue = iif((Type matches regex iQuery or Text matches regex iQuery), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::type or text imatches: ', iQuery ), "")
        };
        // search Text for fabric_e_
        let TextContainsFabric_E = (tableName:string, issue:string, query:string) {
            table(tableName)
            | where Text contains query or Text contains "E_ABORT"
            | where Text !contains "FABRIC_E_CONNECTION_CLOSED_BY_REMOTE_END"
            | extend KnownIssue = iif((Text matches regex query), true, false) 
            | extend Reason = iif(KnownIssue, strcat(issue,' ::text matches: ', query), "")
        };
        union 
        // add known issue signatures here using one of the provided functions in format table, issue description, string pattern
        // use *Matches (regex) only when needed as it is remarkably slower
        // use Any* only when needed
        TextContains(T, "out of disk space", "does not have enough disk space to operate"),
        TextContains(T, "disk full", "0x80070070"),
        TextContains(T, "stuck replica", "is stuck"),
        TypeContains(T, "ReplicationQueueWarning", "ReplicationQueueWarning"),
        TypeContains(T, "ReplicationQueueFull", "ReplicationQueueFull"),
        TypeContains(T,"api slow", "api.slow"),
        TextContains(T,"slow progress", "DueToSlowProgress=True"),
        TypeContains(T, "node performance issues lease slow send", "Lease.SlowSendCompletion"),
        TypeContains(T, "node performance issues lease send queue full", "Lease.SendQueueFull"),
        TypeAndTextContains(T, "lease node heartbeat disabled", "LeaseAgent.Heartbeat", "is disabled"),
        TextContains(T, "replica performance 0x80071cf7", "0x80071cf7"),
        TextContains(T, "communication errors", "failed with status -107374"),
        TextContains(T, "port exhaustion", "failed to bind to local port for connecting: 0x80072747"),
        TypeAndTextContains(T, "rolling back", "CM.UpgradeRequest", "state=RollingBack"),
        TextContains(T, "health check fail", "health check failed"),
        TypeContains(T, "crash dumps in storage account", "crashdumpfound"),
        TypeOrTextContains(T, "exception", "exception"),
        TextContains(T, "cancellation token issue? (not confirmed)", "RunAsync is taking longer then expected time (15s) to cancel."),
        TextContains(T, "possible certificate trust issue if not self-signed cert. check CA connectivity and intermediate certs.","0x800b0109"),
        TypeContains(T, "node open failure", "FabricNode._NodesOps_NodeOpenedFailed"),
        TextContains(T, "expired certificate. use TSG: https://github.com/Azure/Service-Fabric-Troubleshooting-Guides/blob/master/Security/How%20to%20recover%20from%20an%20Expired%20Cluster%20Certificate.md", "SFRP poll: Exception encountered: System.InvalidOperationException: Could not load primary and secondary certificate"),
        TypeContains(T, "reverse proxy errors", "ReverseProxy.SendResponseError"),
        TypeContains(T, "reverse proxy errors", "ReverseProxy.ProcessRequestError"),
        TypeContains(T, "reverse proxy errors", "ReverseProxy.EndProcessReverseProxyRequestFailed"),
        TypeAndTextContains(T, "reverse proxy", "ReverseProxy.ServiceResponseReresolve", "reresolving"),
        TypeAndTextContains(T, "reverse proxy errors possible port / app issue", "ReverseProxy.SendResponseError","SendResponseChunk, error = 3489660929"),
        TypeAndTextMatches(T, "quorum loss reported", "FM.FailoverUnitCounts", "QuorumLoss=[^0]"),
        TypeAndTextMatches(T, "unhealthy nodes reported", "FM.FailoverUnitCounts", "Unhealthy=[^0]"),
        TypeAndTextMatches(T, "offline nodes reported", "FM.FailoverUnitCounts", "Offline=[^0]"),
        TypeAndTextMatches(T, "deactivated nodes reported", "FM.NodeCounts", "Deactivated=[^0]"),
        TypeAndTextMatches(T, "down nodes reported", "FM.NodeCounts", "Down=[^0]"),
        TypeAndTextMatches(T, "removed nodes reported", "FM.NodeCounts", "Removed=[^0]"),
        TypeAndTextMatches(T, "cm upgrade error", "CM.UpgradeReply","Error = [^S_OK]"),
        TextContains(T, ".net exception", "3762504530"),
        TypeAndTextContains(T, "fabric client making too many connections to gateway", "EntreeServiceProxy.LifeCycle", "exceeded client connection limit:"),
        TypeContains(T, "stuck .net timers detected", "FabricDCA.DCADotNetStuckTimersDetected"),
        TypeAndTextContains(T, "sf 7.0cu3 known issue. icm 176184624. fix cu4","HM.", @"There was an error during download. Failed to download 'WindowsFabricStore\ClusterManifest"),
        TypeAndTextContains(T, "transport network connectivity issues", "Transport.Connection", "connection open timeout"),
        TextContainsFabric_E(T, "FABRIC_E_ errors use TraceFabric_E_ErrorsDistinct('') function to view.", "FABRIC_E_"),
        TextContains(T, "docker health error", "Docker HEALTHCHECK reported health_status=unhealthy"),
        TypeAndTextContains(T, "docker container not responsive", "ManagedHosting.ContainerEventManager", "Failed to connect to DockerService at named pipe 'docker_engine'"),
        TypeAndTextContains(T, "container activation issues", "ManagedHosting.ActivateContainerOperation", "Failed to start Container"),
        TypeAndTextContains(T, "possible container hns nat issue", "FabricDeployer.FabricDeployer", "Failed to set up container network")
    }